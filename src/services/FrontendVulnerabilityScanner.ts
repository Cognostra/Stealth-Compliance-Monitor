/**
 * FrontendVulnerabilityScanner Service
 *
 * Detects known vulnerable JavaScript libraries loaded in the browser.
 * Based on RetireJS vulnerability database patterns.
 *
 * Checks for:
 * - jQuery < 3.5.0 (XSS vulnerabilities)
 * - Lodash < 4.17.21 (Prototype Pollution)
 * - Angular < 1.8.0 (XSS, Template Injection)
 * - React < 16.13.0 (DOM XSS)
 * - Moment.js (ReDoS in parsing)
 * - Bootstrap < 4.3.1 (XSS in tooltips)
 * - etc.
 * 
 * Implements IScanner for registry-based lifecycle management.
 */

import { Page, Response } from 'playwright';
import { IScanner } from '../core/ScannerRegistry.js';
import { logger } from '../utils/logger.js';

export interface VulnerableLibrary {
    name: string;
    version: string;
    severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';
    vulnerabilities: Array<{ cve: string; description: string }>;
    recommendation: string;
}

interface LibraryPattern {
    name: string;
    detectVersion: (content: string) => string | null;
    vulnerableVersions: {
        below: string;
        severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';
        vulnerabilities: string[];
        cves?: string[];
    }[];
}

// Version comparison helper
function compareVersions(v1: string, v2: string): number {
    const parts1 = v1.split('.').map(Number);
    const parts2 = v2.split('.').map(Number);

    for (let i = 0; i < Math.max(parts1.length, parts2.length); i++) {
        const p1 = parts1[i] || 0;
        const p2 = parts2[i] || 0;
        if (p1 < p2) return -1;
        if (p1 > p2) return 1;
    }
    return 0;
}

// Library detection patterns (simplified RetireJS-style)
const LIBRARY_PATTERNS: LibraryPattern[] = [
    {
        name: 'jQuery',
        detectVersion: (content) => {
            const patterns = [
                /jquery[./\-](\d+\.\d+\.\d+)/i,
                /jQuery v(\d+\.\d+\.\d+)/,
                /jquery.*version.*["'](\d+\.\d+\.\d+)["']/i,
            ];
            for (const pattern of patterns) {
                const match = pattern.exec(content);
                if (match) return match[1];
            }
            return null;
        },
        vulnerableVersions: [
            {
                below: '3.5.0',
                severity: 'MEDIUM',
                vulnerabilities: ['XSS via jQuery.htmlPrefilter', 'Prototype Pollution'],
                cves: ['CVE-2020-11022', 'CVE-2020-11023']
            },
            {
                below: '3.0.0',
                severity: 'HIGH',
                vulnerabilities: ['Multiple XSS vulnerabilities', 'Selector-injection'],
                cves: ['CVE-2015-9251', 'CVE-2019-11358']
            },
        ]
    },
    {
        name: 'Lodash',
        detectVersion: (content) => {
            const patterns = [
                /lodash[./\-](\d+\.\d+\.\d+)/i,
                /lodash.*version.*["'](\d+\.\d+\.\d+)["']/i,
                /__VERSION__.*["'](\d+\.\d+\.\d+)["'].*lodash/i,
            ];
            for (const pattern of patterns) {
                const match = pattern.exec(content);
                if (match) return match[1];
            }
            return null;
        },
        vulnerableVersions: [
            {
                below: '4.17.21',
                severity: 'HIGH',
                vulnerabilities: ['Prototype Pollution via zipObjectDeep', 'Command Injection'],
                cves: ['CVE-2021-23337', 'CVE-2020-8203']
            },
            {
                below: '4.17.12',
                severity: 'CRITICAL',
                vulnerabilities: ['Prototype Pollution multiple vectors'],
                cves: ['CVE-2019-10744']
            },
        ]
    },
    {
        name: 'AngularJS',
        detectVersion: (content) => {
            const patterns = [
                /angular[./\-](\d+\.\d+\.\d+)/i,
                /AngularJS v(\d+\.\d+\.\d+)/,
            ];
            for (const pattern of patterns) {
                const match = pattern.exec(content);
                if (match) return match[1];
            }
            return null;
        },
        vulnerableVersions: [
            {
                below: '1.8.0',
                severity: 'HIGH',
                vulnerabilities: ['XSS via SVG animations', 'Template injection'],
                cves: ['CVE-2022-25869']
            },
            {
                below: '1.6.0',
                severity: 'CRITICAL',
                vulnerabilities: ['Sandbox escape', 'Arbitrary code execution'],
                cves: ['CVE-2019-14863']
            },
        ]
    },
    {
        name: 'Bootstrap',
        detectVersion: (content) => {
            const patterns = [
                /bootstrap[./\-](\d+\.\d+\.\d+)/i,
                /Bootstrap v(\d+\.\d+\.\d+)/,
            ];
            for (const pattern of patterns) {
                const match = pattern.exec(content);
                if (match) return match[1];
            }
            return null;
        },
        vulnerableVersions: [
            {
                below: '4.3.1',
                severity: 'MEDIUM',
                vulnerabilities: ['XSS in data-template and data-content attributes'],
                cves: ['CVE-2019-8331']
            },
            {
                below: '3.4.0',
                severity: 'HIGH',
                vulnerabilities: ['XSS in tooltip/popover data-target'],
                cves: ['CVE-2018-14041', 'CVE-2018-14042']
            },
        ]
    },
    {
        name: 'Moment.js',
        detectVersion: (content) => {
            const patterns = [
                /moment[./\-](\d+\.\d+\.\d+)/i,
                /moment.*version.*["'](\d+\.\d+\.\d+)["']/i,
            ];
            for (const pattern of patterns) {
                const match = pattern.exec(content);
                if (match) return match[1];
            }
            return null;
        },
        vulnerableVersions: [
            {
                below: '2.29.4',
                severity: 'HIGH',
                vulnerabilities: ['Path Traversal', 'ReDoS in string parsing'],
                cves: ['CVE-2022-31129', 'CVE-2022-24785']
            },
        ]
    },
    {
        name: 'Handlebars',
        detectVersion: (content) => {
            const patterns = [
                /handlebars[./\-](\d+\.\d+\.\d+)/i,
                /Handlebars.*(\d+\.\d+\.\d+)/,
            ];
            for (const pattern of patterns) {
                const match = pattern.exec(content);
                if (match) return match[1];
            }
            return null;
        },
        vulnerableVersions: [
            {
                below: '4.7.7',
                severity: 'CRITICAL',
                vulnerabilities: ['Prototype Pollution leading to RCE'],
                cves: ['CVE-2021-23369', 'CVE-2021-23383']
            },
        ]
    },
    {
        name: 'DOMPurify',
        detectVersion: (content) => {
            const patterns = [
                /dompurify[./\-](\d+\.\d+\.\d+)/i,
                /DOMPurify.*(\d+\.\d+\.\d+)/,
            ];
            for (const pattern of patterns) {
                const match = pattern.exec(content);
                if (match) return match[1];
            }
            return null;
        },
        vulnerableVersions: [
            {
                below: '2.3.6',
                severity: 'HIGH',
                vulnerabilities: ['mXSS bypass via form elements'],
                cves: ['CVE-2022-25892']
            },
        ]
    },
    {
        name: 'Axios',
        detectVersion: (content) => {
            const patterns = [
                /axios[./\-](\d+\.\d+\.\d+)/i,
                /axios.*version.*["'](\d+\.\d+\.\d+)["']/i,
            ];
            for (const pattern of patterns) {
                const match = pattern.exec(content);
                if (match) return match[1];
            }
            return null;
        },
        vulnerableVersions: [
            {
                below: '1.6.0',
                severity: 'HIGH',
                vulnerabilities: ['CSRF token leakage via cross-origin requests'],
                cves: ['CVE-2023-45857']
            },
            {
                below: '0.21.2',
                severity: 'MEDIUM',
                vulnerabilities: ['Server-Side Request Forgery'],
                cves: ['CVE-2021-3749']
            },
        ]
    },
];

export class FrontendVulnerabilityScanner implements IScanner {
    readonly name = 'FrontendVulnerabilityScanner';

    private vulnerableLibraries: VulnerableLibrary[] = [];
    private detectedLibraries: Map<string, string> = new Map();
    private scannedUrls: Set<string> = new Set();
    private page: Page | null = null;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // IScanner Lifecycle Hooks
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Called when page is created
     */
    onPageCreated(page: Page): void {
        this.page = page;
        logger.info('  ğŸ“¦ Frontend Vulnerability Scanner attached');
    }

    /**
     * Called for each network response - scan JavaScript files
     */
    async onResponse(response: Response): Promise<void> {
        try {
            const url = response.url();
            const contentType = response.headers()['content-type'] || '';

            // Scan JavaScript files
            if (
                (contentType.includes('javascript') || url.endsWith('.js')) &&
                !this.scannedUrls.has(url)
            ) {
                this.scannedUrls.add(url);

                try {
                    const content = await response.text();
                    this.scanForLibraries(url, content);
                } catch (e) {
                    logger.debug(`VulnScanner: Could not read ${url.substring(0, 60)}`);
                }
            }
        } catch (e) {
            logger.debug(`VulnScanner error: ${e instanceof Error ? e.message : String(e)}`);
        }
    }

    /**
     * Called during shutdown
     */
    onClose(): void {
        logger.debug(`VulnScanner: Found ${this.vulnerableLibraries.length} vulnerable libraries`);
    }

    /**
     * Get collected results
     */
    getResults(): VulnerableLibrary[] {
        return this.getVulnerableLibraries();
    }

    /**
     * Clear scanner state
     */
    clear(): void {
        this.vulnerableLibraries = [];
        this.detectedLibraries.clear();
        this.scannedUrls.clear();
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Legacy API (for backward compatibility)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * @deprecated Use ScannerRegistry.register() instead
     * Legacy attach method for backward compatibility
     */
    attach(page: Page): void {
        this.onPageCreated(page);

        page.on('response', async (response) => {
            await this.onResponse(response);
        });
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Core Logic
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * Additionally check global variables after page load
     */
    async scanPageGlobals(page: Page): Promise<void> {
        try {
            const versions = await page.evaluate(() => {
                const detected: Record<string, string> = {};

                // Check common global variables
                if (typeof (window as any).jQuery !== 'undefined') {
                    detected['jQuery'] = (window as any).jQuery.fn?.jquery || 'unknown';
                }
                if (typeof (window as any)._ !== 'undefined' && (window as any)._.VERSION) {
                    detected['Lodash'] = (window as any)._.VERSION;
                }
                if (typeof (window as any).angular !== 'undefined') {
                    detected['AngularJS'] = (window as any).angular.version?.full || 'unknown';
                }
                if (typeof (window as any).moment !== 'undefined') {
                    detected['Moment.js'] = (window as any).moment.version || 'unknown';
                }
                if (typeof (window as any).React !== 'undefined') {
                    detected['React'] = (window as any).React.version || 'unknown';
                }
                if (typeof (window as any).Vue !== 'undefined') {
                    detected['Vue'] = (window as any).Vue.version || 'unknown';
                }

                return detected;
            });

            // Check detected versions against vulnerability database
            for (const [lib, version] of Object.entries(versions)) {
                if (version && version !== 'unknown') {
                    this.checkLibraryVersion(lib, version);
                }
            }
        } catch (e) {
            logger.debug(`Global variable scan failed: ${e}`);
        }
    }

    /**
     * Scan content for library signatures
     */
    private scanForLibraries(sourceUrl: string, content: string): void {
        for (const pattern of LIBRARY_PATTERNS) {
            const version = pattern.detectVersion(content);
            if (version) {
                // Avoid duplicate detections
                const existing = this.detectedLibraries.get(pattern.name);
                if (!existing || compareVersions(version, existing) < 0) {
                    this.detectedLibraries.set(pattern.name, version);
                    this.checkLibraryVersion(pattern.name, version);
                }
            }
        }
    }

    /**
     * Check if detected version is vulnerable
     */
    private checkLibraryVersion(libraryName: string, version: string): void {
        const pattern = LIBRARY_PATTERNS.find(p => p.name === libraryName);
        if (!pattern) return;

        for (const vuln of pattern.vulnerableVersions) {
            if (compareVersions(version, vuln.below) < 0) {
                // Check if we already reported this
                const existing = this.vulnerableLibraries.find(
                    v => v.name === libraryName && v.version === version
                );
                if (existing) return;

                logger.warn(`âš ï¸ Vulnerable library detected: ${libraryName} ${version} (< ${vuln.below})`);

                // Convert to expected format
                const vulnerabilities = vuln.vulnerabilities.map((desc, i) => ({
                    cve: vuln.cves?.[i] || `VULN-${i + 1}`,
                    description: desc
                }));

                this.vulnerableLibraries.push({
                    name: libraryName,
                    version,
                    severity: vuln.severity,
                    vulnerabilities,
                    recommendation: `Update ${libraryName} to version ${vuln.below} or later`
                });

                return; // Only report worst vulnerability
            }
        }
    }

    /**
     * Get detected vulnerable libraries
     */
    getVulnerableLibraries(): VulnerableLibrary[] {
        return [...this.vulnerableLibraries];
    }

    /**
     * Get all detected libraries (for informational purposes)
     */
    getDetectedLibraries(): Map<string, string> {
        return new Map(this.detectedLibraries);
    }
}

export default FrontendVulnerabilityScanner;
